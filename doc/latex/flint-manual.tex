% vim: spell spelllang=en textwidth=80
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   This file is part of FLINT.
%
%    FLINT is free software: you can redistribute it and/or modify it under
%    the terms of the GNU Lesser General Public License (LGPL) as published
%    by the Free Software Foundation; either version 2.1 of the License, or
%    (at your option) any later version.  See <https://www.gnu.org/licenses/>.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   Copyright (C) 2007 William Hart, David Harvey
%   Copyright (C) 2010 Sebastian Pancratz
%   Copyright (C) 2013 Tom Bachmann
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper,10pt]{book}

%%%%%%%%%%%%
% geometry %
%%%%%%%%%%%%

\usepackage[hmargin=3.8cm,vmargin=3cm,a4paper,centering,twoside]{geometry}
\setlength{\headheight}{14pt}

% Dutch style of paragraph formatting, i.e. no indents
\setlength{\parskip}{1.3ex plus 0.2ex minus 0.2ex}
\setlength{\parindent}{0pt}

%%%%%%%%%%%%%%%%%%
% Other packages %
%%%%%%%%%%%%%%%%%%

\usepackage{amsmath,amsthm,amscd,amsfonts,amssymb}
\usepackage{cases}
\usepackage[all]{xy}

\usepackage{ifpdf}
\usepackage{paralist}
\usepackage{fancyhdr}
\usepackage{sectsty}
\usepackage{epigraph}
\usepackage{natbib}
\usepackage{url}
\usepackage[T1]{fontenc}
\usepackage{ae,aecompl}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{verbatim}
\usepackage{listings}

%%%%%%%%%%%%
% hyperref %
%%%%%%%%%%%%

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,    % false: boxed links; true: colored links
    citecolor=green,    % color of links to bibliography
    filecolor=red,      % color of file links
    linkcolor=blue,     % color of internal links
    urlcolor=blue       % color of external links
}

\makeatletter
\newcommand\org@hypertarget{}
\let\org@hypertarget\hypertarget
\renewcommand\hypertarget[2]{%
    \Hy@raisedlink{\org@hypertarget{#1}{}}#2%
}
\makeatother

\ifpdf
    \hypersetup{
        pdftitle={FLINT},
        pdfauthor={},
        pdfsubject={Computational mathematics},
        bookmarks=true,
        bookmarksnumbered=true,
        unicode=true,
        pdfstartview={FitH},
        pdfpagemode={UseOutlines}
    }
\fi

%%%%%%%%%%
% natbib %
%%%%%%%%%%

\bibpunct{[}{]}{,}{n}{}{}

\renewcommand{\bibname}{References}

%%%%%%%%%%%
% sectsty %
%%%%%%%%%%%

\allsectionsfont{\nohang\centering}

\sectionfont{\nohang\centering\large}

\makeatletter
\renewcommand{\@makechapterhead}[1]{%
\vspace*{50 pt}%
\begin{center}
\bfseries\Huge\S \thechapter.\ #1
\end{center}
\vspace*{40 pt}}
\makeatother

%%%%%%%%%%%%%%%%%%%%%
% Table of contents %
%%%%%%%%%%%%%%%%%%%%%

\usepackage{tocloft}

\addtolength{\cftsecnumwidth}{0.8em}
\addtolength{\cftsubsecnumwidth}{0.8em}
\addtolength{\cftbeforesecskip}{0.05em}

%%%%%%%%%%%%
% fancyhdr %
%%%%%%%%%%%%

\newcommand\nouppercase[1]{{%
    \let\uppercase\relax
    \let\MakeUppercase\relax
    \expandafter\let\csname MakeUppercase \endcsname\relax#1}%
}

\pagestyle{fancyplain}

\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
\fancyhf{}
\fancyhead[LE,RO]{\bfseries\thepage}
\fancyhead[LO]{\itshape\nouppercase{\rightmark}}
\fancyhead[RE]{\itshape\nouppercase{\leftmark}}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

\fancypagestyle{plain}{%
  \fancyhead{}
  \renewcommand{\headrulewidth}{0pt}
}

\makeatletter
\def\cleardoublepage{\clearpage\if@twoside \ifodd\c@page\else
    \hbox{}
    \thispagestyle{plain}
    \newpage
    \if@twocolumn\hbox{}\newpage\fi\fi\fi}
\makeatother \clearpage{\pagestyle{plain}\cleardoublepage}

%%%%%%%
% url %
%%%%%%%

\makeatletter
\def\url@leostyle{%
  \@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\ttfamily}}}
\makeatother
\urlstyle{leostyle}

%%%%%%%%%%%%%%%%
% Enumerations %
%%%%%%%%%%%%%%%%

\setlength{\pltopsep}{0.24em}
\setlength{\plpartopsep}{0em}
\setlength{\plitemsep}{0.24em}

% This should do what we want
%   \setdefaultenum{(i)}{(a)}{1.}{A}
% but it does not work for references, dropping the
% parentheses.  The following hack does work.

\renewcommand{\theenumi}{(\roman{enumi})}
\renewcommand{\theenumii}{(\alph{enumii})}
\renewcommand{\theenumiii}{\arabic{enumiii}.}
\renewcommand{\theenumiv}{\Alph{enumiv}}

\renewcommand{\labelenumi}{\theenumi}
\renewcommand{\labelenumii}{\theenumii}
\renewcommand{\labelenumiii}{\theenumiii}
\renewcommand{\labelenumiv}{\theenumiv}

%%%%%%%%%%%%%%%%%%%%%%%%%
% Mathematical commands %
%%%%%%%%%%%%%%%%%%%%%%%%%

\renewcommand{\to}{\rightarrow}%         Right arrow
\newcommand{\into}{\hookrightarrow}%     Injection arrow
\newcommand{\onto}{\twoheadrightarrow}%  Surjection arrow

\providecommand{\abs}[1]{\lvert#1\rvert}%                  Absolute value
\providecommand{\absbig}[1]{\bigl\lvert#1\bigr\rvert}%     Absolute value
\providecommand{\absBig}[1]{\Bigl\lvert#1\Bigr\rvert}%     Absolute value
\providecommand{\absbigg}[1]{\biggl\lvert#1\biggr\rvert}%  Absolute value

\providecommand{\norm}[1]{\lVert#1\rVert}%               Norm
\providecommand{\normbig}[1]{\bigl\lVert#1\bigr\rVert}%  Norm
\providecommand{\normBig}[1]{\Bigl\lVert#1\Bigr\rVert}%  Norm

\providecommand{\floor}[1]{\left\lfloor#1\right\rfloor}%    Floor
\providecommand{\floorbig}[1]{\bigl\lfloor#1\bigr\rfloor}%  Floor
\providecommand{\floorBig}[1]{\Bigl\lfloor#1\Bigr\rfloor}%  Floor

\providecommand{\ceil}[1]{\left\lceil#1\right\rceil}%    Ceiling
\providecommand{\ceilbig}[1]{\bigl\lceil#1\bigr\rceil}%  Ceiling
\providecommand{\ceilBig}[1]{\Bigl\lceil#1\Bigr\rceil}%  Ceiling

\newcommand{\N}{\mathbf{N}}%  Natural numbers
\newcommand{\Z}{\mathbf{Z}}%  Integers
\newcommand{\Q}{\mathbf{Q}}%  Rationals
\newcommand{\F}{\mathbf{F}}%  Finite fields

\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\ord}{ord}
\DeclareMathOperator{\lcm}{lcm}
\DeclareMathOperator{\Gal}{Gal}
\DeclareMathOperator{\Norm}{N}
\DeclareMathOperator{\Trace}{Tr}
\DeclareMathOperator{\Res}{Res}

\allowdisplaybreaks[4]
%\numberwithin{equation}{section}

%%%%%%%%%%%%
% listings %
%%%%%%%%%%%%

\lstset{language=c}
\lstset{basicstyle=\ttfamily}
\lstset{breaklines=true}
\lstset{breakatwhitespace=true}
\lstset{keywordstyle=}
\lstset{morekeywords={mpz_t, mpq_t, mpz_poly_t, fmpz, fmpz_t, fmpz_poly_t}}
\lstset{escapechar=}
\lstset{showstringspaces=false}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FLINT specific commands %
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\code}{\lstinline}

\DeclareMathOperator{\len}{len}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENT                                                                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FRONTMATTER                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frontmatter

\input{input/title.tex}
\clearpage

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MAINMATTER                                                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\mainmatter

\chapter{Introduction}

FLINT is a C library of functions for doing number theory. It is highly
optimised and can be compiled on numerous platforms.  FLINT also has the
aim of providing support for multicore and multiprocessor computer
architectures. To this end, the library is threadsafe, with few exceptions
noted in the appropriate place.

FLINT is currently maintained by William Hart of Technische Universit\"{a}t
in Kaiserslautern and Fredrik Johansson of INRIA Bordeaux.

FLINT was originally designed by William Hart and David Harvey. Since then
FLINT was rewritten as FLINT 2 by William Hart, Fredrik Johansson and
Sebastian Pancratz. Many other substantial contributions have been made
by other authors. (See the Contributors list below for a list.)

FLINT 2 and following should compile on any machine with GCC and a standard
GNU toolchain, however it is specially optimised for x86 (32 and 64 bit)
machines. There is also limited optimisation for ARM and ia64 machines. As
of version 2.0, FLINT required GCC version 2.96 or later, either MPIR
(2.6.0 or later) or GMP (5.1.1 or later), and MPFR 3.0.0 or later.
It is also required that the platform
provide a \code{uint64_t} type if a native 64 bit type is not available.
Full C99 compliance is \textbf{not} required.

FLINT is supplied as a set of modules, \code{fmpz}, \code{fmpz_poly}, etc.,
each of which can be linked to a C program making use of their functionality.

All of the functions in FLINT have a corresponding test function provided
in an appropriately named test file.  For example, the function
\code{fmpz_poly_add} located in\\ \code{fmpz_poly/add.c} has test code in the
file \code{fmpz_poly/test/t-add.c}.

FLINT is distributed under the GNU Lesser General Public License (LGPL).
There is a copy of the license included with this document.

\chapter{Configuring FLINT}

The easiest way to use FLINT is to build a shared library. Simply download
the FLINT tarball and untar it on your system.

FLINT requires either MPIR (version 2.6.0 or later) or GMP
(version 5.1.1 or later). If MPIR is used, MPIR must be built with
the \code{--enable-gmpcompat} option. FLINT also requires
MPFR 3.0.0 or later and a pthread implementation.
Some of the input/output tests require
\code{fork} and \code{pipe}, however these are disabled on MinGW which
does not provide a posix implementation.

If it happens that GMP/MPIR and MPFR are not in a standard location
on your system (e.g. not in /usr/include/ and /usr/lib/), you need
to tell the configure script where they are with the options
\code{--with-gmp}, \code{--with-mpir} or \code{--with-mpfr}.
For example
\begin{lstlisting}[language=bash]
./configure --with-gmp=/my/directory/ --with-mpfr=/my/directory/
\end{lstlisting}
or alternatively when using MPIR
\begin{lstlisting}[language=bash]
./configure --with-mpir=/my/directory/ --with-mpfr=/my/directory/
\end{lstlisting}
FLINT can also handle a source build of GMP/MPIR and MPFR. Though
programs using FLINT will require GMP/MPIR and MPFR to be
installed (via \code{make install} if built from sources). This is
in particular true for the test code for FLINT: running \code{make check}
requires GMP/MPIR and MPFR to be installed.

Note that FLINT builds static and shared libraries by default, except
on platforms where this is not supported. If you do not require either
a shared or static library then you may pass \code{--disable-static}
or \code{--disable-shared} to \code{configure}.

If you intend to install the FLINT library and header files,
you can specify where they should be placed by passing
\code{--prefix=path} to configure, where \code{path} is the directory
under which the \code{lib} and \code{include} directories exist into
which you wish to place the FLINT files when it is installed.

\chapter{TLS, reentrancy and single mode}

If you wish to use FLINT on a single core machine then it can be
configured for single mode. This mode can also be explicitly selected
by passing the \code{--single} option to configure. Single mode is
slightly faster, but by default uses thread local storage if threads
are used, and this is not available on some machines.

FLINT uses thread local storage by default (\code{--enable-tls}).
However, if reentrancy is required on systems that do not support
this, one can pass \code{--disable-tls} and mutexes will be used
instead (requires POSIX).

If you wish to build a threadsafe version of FLINT which uses a
less complicated memory model (slower, but still works in the absence
of TLS) you can pass the \code{--reentrant} option to configure.

\chapter{ABI and architecture support}

On some systems, e.g. Sparc and some Macs, more than one ABI is
available. FLINT chooses the ABI based on the CPU type available,
however its default choice can be overridden by passing either
\code{ABI=64} or \code{ABI=32} to configure.

To build on MinGW64 it is necessary to pass \code{ABI=64} to
configure, as FLINT is otherwise unable to distinguish it from
MinGW32.

In some cases, it is necessary to override the entire CPU/OS
defaults. This can be done by passing \code{--build=cpu-os} to
configure. The available choices for CPU include \code{x86_64},
\code{x86}, \code{ia64}, \code{sparc}, \code{sparc64}, \code{ppc},
\code{ppc64}. Other CPU types are unrecognised and FLINT will
build with generic code on those machines. The choices for OS
include \code{Linux}, \code{MINGW32}, \code{MINGW64},
\code{CYGWIN32}, \code{CYGWIN64}, \code{Darwin}, \code{FreeBSD},
\code{SunOS} and numerous other operating systems.

It is also possible to override the default CC, AR and CFLAGS used
by FLINT by passing \code{CC=full_path_to_compiler}, etc., to
FLINT's configure.

\chapter{Building FLINT2 with Microsoft Visual Studio 2015}

Dr. Brian Gladman has kindly provided the build scripts for building
Flint with Microsoft Visual Studio.

Building FLINT2 with Microsoft Visual Studio requires 
Visual Studio 2015 Community (or higher version) and:
\begin{itemize}
\item an installed version of Python 3
\item an installed version of Python Tools 
         for Visual Studio (\url{https://github.com/Microsoft/PTVS})
\end{itemize}

Obtain FLINT2 either as a released distribution or clone it using
GIT from:

\indent \url{git@github.com:BrianGladman/flint2.git}

FLINT2 depends on the MPIR, MPFR and PTHREADS libraries that have
to be installed and built using Visual Studio before FLINT2 can
be built.  The application directories are assumed to be in the
same root directory with the names and layouts:
   
\begin{verbatim}
    mpir
       build.vc14
       lib
       dll
    mpfr  
       build.vc14
       lib
       dll
    pthreads  
       build.vc14
       lib
       dll
    flint2
       build.vc14
       lib
       dll
\end{verbatim}
   
where the build.vc14 directories hold the Visual Studio build
files and the lib and dll directories hold the static and dynamic
library outputs for each package.  Libraries on which FLINT2
depends have to be built for the same configuration that will be 
used to build FLINT2 before FLINT2 itself can be built:
\begin{itemize}
\item <Static Library|Dynamic Link Library>
\item <Win32|x64>
\item <Release|Debug>
\end{itemize}
where <a|b> shows the choices (a or b) that have to be made.   

Opening the solution file flint.sln in Visual Studio 2015 provides
the following build projects:

\begin{verbatim}
    dll_flint     - a Visual Studio build project for
                    FLINT2 as a Dynamic Link Library
    lib_flint     - a Visual Studio build project for
                    FLINT2 as a Static Library
    flint_config  - a Python program for creating the Visual 
                    Studio build files
    build_tests   - a Python program for building the FLINT2
                    tests (after they have been created)
    run_tests     - a Python program for running the FLINT2
                    tests (after they have been built)
\end{verbatim}

The projects \code{lib_flint} and \code{dll_flint} can be used immediately to
build FLINT2 as a Static and Dynamic Link Library respectively.
Before building one or both of these, you need to select the
architecture (Win32 or x64) and the build type (Release or Debug).

To run the FLINT2 tests, the necessary Visual Studio build files
have to be created.  If you have Python and Python Tools for
Visual Studio (PTVS) installed, this is done by setting the 
project \code{flint_config} (loaded into Visual Studio by the solution
file flint.sln) as the start-up project and then running it.
If you don't have PTVS installed but you do have Python, you
can run \code{flint_config.py} directly without Visual Studio. 
   
By default \code{flint_config} creates only the FLINT2 tests and profiling.
But it can also recreate the Visual Studio 2015 build files for the
FLINT2 DLL and Static Libraries by changing the defines at the
start of \code{flint_config.py}: 

\begin{verbatim}
    build_lib = False
    build_dll = False
    build_tests = True
    build_profiles = True
\end{verbatim}

Rebuilding the library build files in this way may be necessary
if FLINT2 has been updated since it was first downloaded. 
      
After the FLINT2 tests have been created using \code{flint_config.py},
they can then be built by setting \code{build_tests.py} as the start up
project and then running it.

There are also a number of Visual Studio solution files that
provide an \emph{alternative} way of building the FLINT2 tests and
profiling.  However, their use is not recommended because each
of the multiple solution files \code{flint-tests<NN>.sln} (where NN
is a number) has to be loaded and built by Visual Studio (this
approach is used because it takes Visual Studio too long to
load the tests from a single solution file).

Once the tests have been built, the Python project \code{run_tests} can
be set as the start-up project and started to run all the tests 
(or the file \code{run_tests.py} can be run outside Visual Studio).
   
After building FLINT2, the libraries and the header files that 
you need to use FLINT2 are placed in the directories:
\begin{itemize}
\item \code{lib\<Win32|x64>\<Debug|Release>}
\item \code{dll\<Win32|x64>\<Debug|Release>}
\end{itemize}

depending on the version(s) that have been built.


\chapter{Exceptions}

When FLINT encounters a problem, mostly illegal input, it currently aborts.
There is an experimental interface for generating proper exceptions
\code{flint_throw}, but this is almost nowhere used (currently) and
experimental - you should expect for this to change.

At the end, all of FLINT's exceptions call \code{abort()} to terminate
the program. Using \code{flint_set_abort(void (*abort_func)(void))}, the
user can install a function that will be called instead. Similar
to the exceptions, this should be regarded as experimental.

\chapter{Garbage collection}

If building FLINT as part of an application that uses the
Boehm-Demers-Weiser GC library, you may wish to pass the
\code{--with-gc=<path/to/gc/} option to configure. This causes
FLINT to use \code{GC_malloc} and friends for its memory allocation
strategy. The user is responsible for calling \code{GC_init}.

The \code{--with-gc} option can be used with \code{--reentrant}, but not the
\code{--enable-tls} option. In fact, configure will switch this off
automatically and print a warning if it is selected in addition to
\code{--with-gc}.

\chapter{Building, testing, installing and using FLINT}

Once FLINT is configured, in the main directory of the FLINT directory
tree simply type:
\begin{lstlisting}[language=bash]
make
make check
\end{lstlisting}

GNU make or CMake is required to build FLINT. For GNU make, this is
simply \code{make} on Linux, Darwin, MinGW and Cygwin systems. However,
on some unixes the command is \code{gmake}. For CMake, this is
\code{cmake}, which which may need to be installed with your package
manager.

If you wish to install FLINT with GNU make, simply type:
\begin{lstlisting}[language=bash]
make install
\end{lstlisting}

If you wish to install FLINT with CMake, simply type:
\begin{lstlisting}[language=bash]
mkdir build && cd build
cmake .. -DBUILD_SHARED_LIBS=ON
cmake --build . --target install
\end{lstlisting}

Now to use FLINT, simply include the appropriate header files for
the FLINT modules you wish to use in your C program.  Then compile
your program, linking against the FLINT library, GMP/MPIR, MPFR and
pthreads with the options \code{-lflint -lmpfr -lgmp -lpthread}.

Note that you may have to set \code{LD_LIBRARY_PATH} or equivalent
for your system to let the linker know where to find these libraries.
Please refer to your system documentation for how to do this.

If you have any difficulties with conflicts with system headers on
your machine, you can do the following in your code:

\begin{lstlisting}[language=C]
#undef ulong
#define ulong ulongxx
#include <stdio.h>
// other system headers
#undef ulong
#define ulong mp_limb_t
\end{lstlisting}

This prevents FLINT's definition of \code{ulong} interfering with
your system headers.

The FLINT make system responds to the standard commands
\begin{lstlisting}[language=bash]
make
make library
make check
make clean
make distclean
make install
\end{lstlisting}

In addition, if you wish to simply check a single module of FLINT you
can pass the option \code{MOD=modname} to \code{make check}. You can
also pass a list of module names in inverted commas, e.g:

\begin{lstlisting}[language=bash]
make check MOD=ulong_extras
make check MOD="fft fmpz_mat"
\end{lstlisting}

To specify an individual test(s) for any module you can add it 
(or comma separated test list)
after chosen module name followed by the colon, e.g.:

\begin{lstlisting}[language=bash]
make check MOD=ulong_extras:clog,factor,is_prime
make check MOD="fft fmpz_mat:add_sub,charpoly fq_vec:add"
\end{lstlisting}

FLINT has an assert system. If you want a debug build you can pass
\code{--enable-assert} to configure. However, this will slow FLINT
considerably, so asserts should not be enabled (\code{--disable-assert},
the default) for deployment.

If your system supports parallel builds, FLINT will build in parallel,
e.g:
\begin{lstlisting}[language=bash]
make -j4 check
\end{lstlisting}

Note that on some systems, most notably MinGW, parallel make is
supported but can be problematic.

\chapter{FLINT extension modules}

Numerous developers have been building libraries on top of FLINT,
extending its functionality. These projects are known as FLINT
extension modules.

To build a FLINT extension module as part of FLINT, do the following:

$\bullet$ Download the flint extension module and place it somewhere
in your file system.

$\bullet$ Pass \code{--extensions=/path/to/extension} to FLINT's
configure, or if more than one extension is desired use
\code{--extensions="/path/to/extension1 /path/to/extension2"},
etc.

Now most of the options that are available for FLINT are also
available for those extension modules.

Some examples of FLINT extension modules include:

$\bullet$ Arb (by Fredrik Johansson) -- Arbitrary precision floating
point ball arithmetic with rigorous error bounds, over the real and
complex numbers (including polynomials, matrices, calculus and special
functions). \url{https://fredrikj.net/arb/}

$\bullet$ ANTIC (by William Hart and Claus Fieker) -- Algebraic Number
Theory in C. Includes general number field arithmetic and class group
computation. \url{https://github.com/flintlib/antic}

$\bullet$ Bland (by Fredrik Johansson) -- Generic recursive rings over
the basic FLINT types. \url{https://github.com/fredrik-johansson/bland}

See the FLINT website \url{https://flintlib.org/} for a full list.

Writing extension modules is trivial. One should include a top level
directory containing a single directory for each module one wishes to
supply. FLINT expects to find, in the top level, a \code{.h} file with
the same name as each module directory.

Inside each module directory there must be at least one \code{.c} file.
There should also be a \code{test} subdirectory. Test files in the
\code{test} subdirectories should be of the form \code{t-*.c} or
\code{t-*.cpp}.

You may optionally add \code{doc}, \code{profile} and \code{tune}
subdirectories to each module directory. These may be supported by some
later version of FLINT.

\chapter{Test code}

Each module of FLINT has an extensive associated test module.  We
strongly recommend running the test programs before relying on results
from FLINT on your system.

To make and run the test programs, simply type:
\begin{lstlisting}[language=bash]
make check
\end{lstlisting}

in the main FLINT directory after configuring FLINT.

\chapter{Reporting bugs}

The maintainer wishes to be made aware of any and all bugs.  Please send an
email with your bug report to \url{hart_wb@yahoo.com} or report them on the
FLINT devel list \url{https://groups.google.com/group/flint-devel?hl=en}.

If possible please include details of your system, the version of GCC,
the versions of GMP/MPIR and MPFR as well as precise details of how to
replicate the bug.

Note that FLINT needs to be linked against version 2.6.0 or later of MPIR
(or version 5.1.1 or later of GMP), version 3.0.0 or later of MPFR and
must be compiled with gcc version 2.96 or later.

\chapter{Contributors}

FLINT has been developed since 2007 by a large number of people. Initially
the library was started by David Harvey and William Hart. Later maintenance
of the library was taken over solely by William Hart.

The authors of FLINT to date:

$\bullet$ William Hart -- integer and polynomial arithmetic, factorisation and
primality testing, general infrastructure (supported by EPSRC Grant
EP/G004870/1 and DFG Priority programme SPP1489)

$\bullet$ Sebastian Pancratz -- polynomial arithmetic over $\Z$, $\Z/n\Z$ and
$\Q$, $p$-adic and $q$-adic arithmetic, including polynomials and matrices
(supported by ERC Grant 204083)

$\bullet$ Andy Novocin -- LLL, polynomial factorisation over $Z$, polynomial
composition

$\bullet$ Fredrik Johansson -- matrices, polynomial and power series
arithmetic, special functions (supported by Austrian Science Fund FWF Grant
Y464-N18)

$\bullet$ Tom Bachmann -- \code{C++} expressions template wrapper,
documentation parser (Google Summer of Code 2013)

$\bullet$ Mike Hansen -- Finite fields (small and large $\F_q$),
polynomials/matrices over $\F_q$, Finite fields with Zech logarithm
representation, Fast factorisation of polynomials over $\F_q$ (supported by
Macaulay2 developers NSF Grant 1002171)

$\bullet$ Martin Lee -- Fast factorisation of polynomials over $\Z/n\Z$,
faster Brent-Kung modular composition

$\bullet$ David Harvey -- Fast Fourier Transform code, \code{zn_poly} for
polynomial arithmetic over $\Z/n\Z$, \code{mpz_poly}, profiling and
graphing code and many other parts of the FLINT library

$\bullet$ Jan Tuitman -- helped with the $p$-adic interface

$\bullet$ Jason Papadopoulos -- Block Lanczos code for quadratic sieve and
multiprecision complex root finding code for polynomials.

$\bullet$ Gonzalo Tornaria -- Theta function module, Montgomery multiplication
and significant contributions to the $\Z[x]$ modular multiplication code.

$\bullet$ Burcin Erocal -- wrote the primary FLINT wrapper in the SAGE system
(Robert Bradshaw also wrote a preliminary version of this and Martin Albrecht
and others have also contributed to it.)  Burcin also contributed by writing
grant applications via his Lmonade organisation to Google. (Supported by DFG
Priority programme SPP1489.)

$\bullet$ Tom Boothby -- Improved factoring of unsigned longs, detection of
perfect powers

$\bullet$ Andres Goens -- $\F_q$ module and polynomials over $\F_q$ (supported
by DFG Priority program SPP1489)

$\bullet$ Lina Kulakova --  factorisation for polynomials over $\F_p$ for large
$p$ (Google Summer of Code 2012)

$\bullet$ Abhinav Baid -- LLL implementation, Ogita, Rump, Oishi dot product,
Villard algorithm for LLL certification, Schwarz-Rutishauser algorithms for GSO and QR-decomposition (Google Summer of Code 2014)

$\bullet$ Curtis Bright -- Mentoring/planning of LLL implementation, numerous 
patches including 32 bit support

$\bullet$ Alex Best -- Hermite Normal Form implementation including the
Pernet-Stein algorithm and Smith Normal Form implementation including the
Iliopoulos and Kannan-Bachem algorithms. Numerous improvements to nullspace,
rref and rank computations (Google Summer of Code 2014)

$\bullet$ Thomas DuBuisson -- logical ops for fmpz module, patches to the build
system

$\bullet$ Jean-Pierre Flori -- many build system patches and Sage integration

$\bullet$ Frithjof Schulze -- some fmpz functions and various patches

$\bullet$ Daniel Woodhouse -- Contributed an implementation of multivariate
multiplication over $\Z/n\Z$ and used this to implement a fast ``saturation''
algorithm for Laurent polynomials. (Funded by Alessio Corti and Tom Coates
at Imperial College)

$\bullet$ Tomasz Lechowski -- Contributed some NTL and Pari polynomial
profiling code and researched algorithms for polynomials over finite fields.
(Funded by the Nuffield Foundation)

$\bullet$ Daniel Scott -- Researched lazy and relaxed algorithms of Joris van
der Hoeven. (Funded by Warwick University's Undergraduate Research Scholars
Scheme)

$\bullet$ David Howden -- Wrote code for computing Bernoulli numbers mod many
primes, including fast polynomial multiplication over $\Z/p\Z$ specifically for
the task. (Funded by Warwick University's Undergraduate Research Scholars
Scheme)

$\bullet$ Daniel Ellam -- Helped design a module for $p$-adic arithmetic for
FLINT. (Funded by Warwick University's Undergraduate Research Scholars Scheme)

$\bullet$ Richard Howell-Peak -- Wrote polynomial factorisation and
irreducibility testing code for polynomials over $\Z/p\Z$. (Funded by Warwick
University's Undergraduate Research Scholars Scheme)

$\bullet$ Peter Shrimpton -- Wrote code for a basic prime sieve,
Pocklington-Lehmer, Lucas, Fibonacci, BSPW and $n-1$ primality tests and a
Weiferich prime search. (Funded by the Nuffield Foundation)

$\bullet$ Brian Gladman -- MSVC support

$\bullet$ Dana Jacobsen -- test BPSW primality code up to $2^{64}$ against
Feitma's tables and sped up and corrected \code{n_is_prime} and
\code{n_is_probabprime}. Improvements to \code{n_nextprime} and
\code{n_isprime}.

$\bullet$ Anubhav Srivastava contributed horizontal and vertical concatenation
of matrices over $\mathbb{Z}$ and an implementation of the Bodrato matrix
squaring algorithm.

$\bullet$ Dharak Kharod and Prabhdeep Singh Walia both independently
contributed matrix content.

$\bullet$ Alena Sergeicheva contributed a patch to the build system for
individual file testing and also contributed numerous matrix concatenation
functions.

$\bullet$ Kushagra Singh contributed fast cube root and nth root code for word
sized integers, including magic number, Newton iteration, Kahan iteration and
Chebyshev approximation code, he also contributed ECM and Pollard's Rho
factoring algorithm implementations as part of a Google Summer of Code.

$\bullet$ Andreas Enge help with a port to MIPS64.

$\bullet$ Tommy Hofmann implemented Howell and strong echelon form and supplied
some inline functions.

$\bullet$ Ashish Kedia contributed an implementation of the Paterson-Stockmeyer
algorithm

$\bullet$ Nitin Kumar contributed under a Google Summer of Code project to the
quadratic sieve

$\bullet$ Vladimir Glazachev contributed an implementation of the APRCL
primality testing algorithm and Shoup multiplication as part of a Google Summer
of Code

$\bullet$ Dan Roche contributed randprime and nextprime functions for the fmpz
module

$\bullet$ Shivin Shrivastava contributed Fibonacci polynomials and some Taylor
shift improvements

$\bullet$ Alex Griffing contributed integer factor refinement and numerous small
patches

$\bullet$ Vincent Delecroix contributed power sums and some patches

$\bullet$ Aaditya Thakkar contributed Strassen multiplication over Z

$\bullet$ Ralf Stephan contributed Hermite polynomials

$\bullet$ Patches and bug reports have been made by Michael Abshoff,
Didier Deshommes, Craig Citro, Timothy Abbot, Carl Witty, Gonzalo Tornaria,
Jaap Spies, Kiran Kedlaya, William Stein, Kate Minola, Didier Deshommes, Robert
Bradshaw, Serge Torres, Dan Grayson, Martin Lee, Bob Smith, Antony Vennard,
Fr\'{e}d\'{e}ric Chyzak, Julien Puydt, Dana Jacobsen, Michael Jacobson Jr.,
Mike Stillman, Jan Englehardt, Jean-Pierre Flori, Jeroen Demeyer, Shi Bai,
Qingwen Guan, Frithjof Schulze, Robert Baillie, Oleksandr Motsak, Hans
Schoenemann, Janko Boehm, Ahmed Soliman, Francois Bissey, Anton Mellit, Daniel
Roche, Denis Kryskov, Daniel Fabian, Julien Ospald, mgkurtz, Max Goldfar, Max

$\bullet$ In addition Michael Abshoff, William Stein and Robert Bradshaw have
contributed to the build system of FLINT.

$\bullet$ Michael Abshoff deserves special recognition for his help in
resolving a number of difficult build issues which came to light as FLINT was
incorporated into SAGE and for bringing numerous bugs to the attention of the
FLINT maintainers. Michael regularly checked FLINT for memory leaks and
corruption, which directly led to numerous issues being identified early!
He also helped with setting up various pieces of infrastructure for the FLINT
project.

$\bullet$ Numerous people have contributed to wrapping FLINT in Sage and
debugging, including Mike Hansen, Jean-Pierre Flori, Burcin Erocal, Robert
Bradshaw, Martin Albrecht, Sebastian Pancratz, Fredrik Johansson, Jeroen
Demeyer and Leif Lionhardy, amongst others.

Some code (notably \code{longlong.h} and \code{clz_tab.c}) has been used from
the GMP library, whose main author is Torbjorn Granlund.

FLINT 2 was a complete rewrite from scratch which began in about 2010.

\chapter{Tuning FLINT}

FLINT uses a highly optimised Fast Fourier Transform routine for
polynomial multiplication and some integer multiplication routines. This
can be tuned by first typing \code{make tune} and then running the
program \code{build/fft/tune/tune_fft}.

The output of the program can be pasted into  \code{fft_tuning64.in} or
\code{fft_tuning32.in} depending on the ABI of the current platform. FLINT
must then be configured again and a clean build initiated.

Tuning is only necessary if you suspect that very large polynomial and
integer operations (millions of bits) are taking longer than they should.

\chapter{Example programs}

FLINT comes with example programs to demonstrate current and future FLINT
features.  To build the example programs, type:

\begin{lstlisting}[language=bash]
make examples
\end{lstlisting}

The example programs are built in the \code{build/examples} directory.
You must set your \code{LD_LIBRARY_PATH} or equivalent for the flint, mpir
and mpfr libraries. See your operating system documentation to see how to
set this.

The current example programs are:

\code{partitions} Demonstrates the partition counting code, e.g.\\
\code{build/examples/partitions 1000000000} will compute the number of
partitions of \code{10^9}.

\code{delta_qexp}  Computes the $n$-th term of the delta function, e.g.\\
\code{build/examples/delta_qexp 1000000} will compute the one million-th
term of the $q$-expansion of delta.

\code{crt}  Demonstrates the integer Chinese Remainder code, e.g.\
\code{build/examples/crt 10382788} will build up the given integer from
its value mod various primes.

\code{multi_crt}  Demonstrates the fast tree version of the integer Chinese
Remainder code, e.g.\
\code{build/examples/multi_crt 100493287498239 13} will build up the given
integer from its value mod the given number of primes.

\code{stirling_matrix}  Generates Stirling number matrices of the first
and second kind and computes their product, which should come out as the
identity matrix. The matrices are printed to standard output.
For example \code{build/examples/stirling_matrix 10} does this
with 10 by 10 matrices.

\code{fmpz_poly_factor_zassenhaus} Demonstrates the factorisation of a
small polynomial. A larger polynomials is also provided on disk and a
small (obvious) change to the example program will read this file instead
of using the hard coded polynomial.

\code{padic} Gives examples of the usage of many functions in the padic
module.

\code{fmpz_poly_q} Gives a very simple example of the \code{fmpz_poly_q}
module.

\code{fmpz_poly} Gives a very simple example of the \code{fmpz_poly}
module.

\code{fmpq_poly} Gives a very simple example of the \code{fmpq_poly}
module.

Some of the example programs have associated C$++$ versions.

\chapter{FLINT macros}

The file \code{flint.h} contains various useful macros.

The macro constant \code{FLINT_BITS} is set at compile time to be the
number of bits per limb on the machine.  FLINT requires it to be either
32 or 64 bits.  Other architectures are not currently supported.

The macro constant \code{FLINT_D_BITS} is set at compile time to be the
number of bits per double on the machine or one less than the number of
bits per limb, whichever is smaller.  This will have the value 53 or 31
on currently supported architectures.  Numerous internal functions using
precomputed inverses only support operands up to \code{FLINT_D_BITS} bits,
hence the macro.

The macro \code{FLINT_ABS(x)} returns the absolute value of \code{x}
for primitive signed numerical types.  It might fail for least negative
values such as \code{INT_MIN} and \code{WORD_MIN}.

The macro \code{FLINT_MIN(x, y)} returns the minimum of \code{x} and
\code{y} for primitive signed or unsigned numerical types.  This macro
is only safe to use when \code{x} and \code{y} are of the same type,
to avoid problems with integer promotion.

Similar to the previous macro, \code{FLINT_MAX(x, y)} returns the
maximum of \code{x} and \code{y}.

The function \code{FLINT_BIT_COUNT(x)} returns the number of binary bits
required to represent an \code{ulong x}.  If \code{x} is zero,
returns~$0$.

Derived from this there are the two macros \code{FLINT_FLOG2(x)} and
\code{FLINT_CLOG2(x)} which, for any $x \geq 1$, compute $\floor{\log_2{x}}$
and $\ceil{\log_2{x}}$.

To determine the current FLINT version a number of macros are available.
For example, if the current FLINT version is \code{2.4.0} then
\code{__FLINT_VERSION} will have the value $2$, \code{__FLINT_MINOR}
will have the value $4$ and \code{__FLINT_PATCHLEVEL} will have the value
$0$. The \code{__FLINT_RELEASE} macro will have the value $20400$.

The \code{FLINT_VERSION} macro is a static text string giving the version
number, e.g. ``2.4'' or ``2.4.1''. Note that if the final digit is a zero
it is suppressed.

\chapter{Memory management}

The file \code{flint.h} defines functions \code{flint_malloc},
\code{flint_realloc}, \code{flint_calloc} and \code{flint_free}.
They have the same interface as the standard library functions, but
may perform additional error checking.

FLINT may cache some data (such as allocated integers
and tables of prime numbers) to speed up various computations.
If FLINT is built in threadsafe mode, cached data is kept in thread-local
storage by default (unless configured otherwise). Cached data can be freed
by calling the \code{flint_cleanup()} function. It is recommended to call
\code{flint_cleanup()} right before exiting a thread, and at the end of the
main program.

The user can register additional cleanup functions to be invoked
by \code{flint_cleanup()} by passing a pointer
to a function with signature \code{void cleanup_function(void)}
to \code{flint_register_cleanup_function()}.

Flint also makes use of \code{malloc}, \code{realloc}, \code{calloc} and
\code{free} by default to allocate memory internally. The user is able to
override this behaviour by calling \code{__flint_set_memory_functions}
passing the \code{malloc}, \code{realloc}, \code{calloc} and
\code{free} function pointers as parameters (see \code{flint.h} for the
exact prototype).

\chapter{Temporary allocation}

FLINT allows for temporary allocation of memory using \code{alloca}
to allocate on the stack if the allocation is small enough.

The following program demonstrates how to use this facility to
allocate two different arrays.

\begin{lstlisting}[language=C]
#include <gmp.h>
#include "flint.h"

void myfun(void)
{
   /* other variable declarations */
   mp_ptr a, b;
   TMP_INIT;

   /* arbitrary code*/

   TMP_START; /* we are about to do some allocation */

   /* arbitrary code */

   a = TMP_ALLOC(32*sizeof(mp_limb_t));
   b = TMP_ALLOC(64*sizeof(mp_limb_t));

   /* arbitrary code */

   TMP_END; /* cleans up a and b */

   /* arbitrary code */
}
\end{lstlisting}

It is very important to note that temporary allocations should not be
made in recursive functions, as many small allocations on the stack
can exhaust the stack causing a stack overflow.

\chapter{Platform-safe types, format specifiers and constants}

For platform independence, FLINT provides two types \code{ulong}
and \code{slong} to replace \code{unsigned long} and \code{long}
respectively. These are guaranteed to be the same size as GMP's
\code{mp_limb_t} and \code{mp_limb_signed_t} types, respectively.

A full list of types provided by FLINT is available in
\code{code_conventions.txt} in the top-level source tree.

As FLINT supports Windows 64 on which the FLINT \code{ulong} and
\code{slong} types are 64 bits, whilst \code{unsigned long} and
\code{long} are only 32 bits, it is necessary to have a special
format specifier which is 64 bits on Windows 64 instead of the usual
\code{"%lu"} and \code{"%ld"}.

For this purpose FLINT provides its own I/O functions, \code{flint_printf},
\code{flint_fprintf}, \code{flint_sprintf}, \code{flint_scanf},
\code{flint_fscanf} and \code{flint_sscanf}, which work exactly as the
usual system versions, but which take the \code{"%wu"} and \code{"%wd"}
format specifiers, which support FLINT \code{ulong} and \code{slong}
types respectively.

Also, instead of using constants \code{123UL} and \code{123L}, FLINT
provides the macros \code{UWORD(123)} and \code{WORD(123)} respectively
for constants of type \code{ulong} and \code{slong} respectively.

The maximum and minimum values that can be represented by these types
are given by \code{UWORD_MAX} and \code{WORD_MAX} respectively.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Integers                                                                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{fmpz : Arbitrary precision integers}
\epigraph{Arbitrary precision integers}{}

\section{Introduction}

By default, an \code{fmpz_t} is implemented as an array of \code{fmpz}'s of
length one to allow passing by reference as one can do with GMP/ MPIR's
\code{mpz_t} type.  The \code{fmpz_t} type is simply a single limb, though
the user does not need to be aware of this except in one specific case
outlined below.

In all respects, \code{fmpz_t}'s act precisely like GMP/ MPIR's
\code{mpz_t}'s, with automatic memory management, however, in the first
place only one limb is used to implement them.  Once an \code{fmpz_t}
overflows a limb then a multiprecision integer is automatically allocated
and instead of storing the actual integer data the \code{slong} which
implements the type becomes an index into a FLINT wide array of
\code{mpz_t}'s.

These internal implementation details are not important for the user to
understand, except for three important things.

Firstly, \code{fmpz_t}'s will be more efficient than \code{mpz_t}'s for
single limb operations, or more precisely for signed quantities whose
absolute value does not exceed \code{FLINT_BITS - 2} bits.

Secondly, for small integers that fit into \code{FLINT_BITS - 2} bits
much less memory will be used than for an \code{mpz_t}.  When very many
\code{fmpz_t}'s are used, there can be important cache benefits on
account of this.

Thirdly, it is important to understand how to deal with arrays of
\code{fmpz_t}'s.  As for \code{mpz_t}'s, there is an underlying type,
an \code{fmpz}, which can be used to create the array, e.g.\
\begin{lstlisting}
fmpz myarr[100];
\end{lstlisting}
Now recall that an \code{fmpz_t} is an array of length one of \code{fmpz}'s.
Thus, a pointer to an \code{fmpz} can be used in place of an \code{fmpz_t}.
For example, to find the sign of the third integer in our array we would
write
\begin{lstlisting}
int sign = fmpz_sgn(myarr + 2);
\end{lstlisting}

The \code{fmpz} module provides routines for memory management, basic
manipulation and basic arithmetic.

Unless otherwise specified, all functions in this section permit aliasing
between their input arguments and between their input and output
arguments.

\section{Simple example}

The following example computes the square of the integer $7$ and prints
the result.
\begin{lstlisting}[language=c]
#include "fmpz.h"
...
fmpz_t x, y;
fmpz_init(x);
fmpz_init(y);
fmpz_set_ui(x, 7);
fmpz_mul(y, x, x);
fmpz_print(x);
flint_printf("^2 = ");
fmpz_print(y);
flint_printf("\n");
fmpz_clear(x);
fmpz_clear(y);
\end{lstlisting}

The output is:
\begin{lstlisting}
7^2 = 49
\end{lstlisting}

We now describe the functions available in the \code{fmpz} module.

\input{input/fmpz.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Integer vectors                                                              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{fmpz\_vec: Vectors over arbitrary precision integers}
\epigraph{Vectors over $\Z$}{}

\input{input/fmpz_vec.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Integer factorisation                                                        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{fmpz\_factor: Factorisation of arbitrary precision integers}
\epigraph{Factorisation in $\Z$}{}

The \code{fmpz_factor} module is included automatically with
\code{fmpz.h}. One should not try to include \code{fmpz_factor.h}
directly.

\input{input/fmpz_factor.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Integer matrices                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{fmpz\_mat: Matrices over arbitrary precision integers}
\epigraph{Matrices over $\Z$}{}

\section{Introduction}

The \code{fmpz_mat_t} data type represents dense matrices of multiprecision
integers, implemented using \code{fmpz} vectors.

No automatic resizing is performed: in general, the user must provide
matrices of correct dimensions for both input and output variables. Output
variables are \emph{not} allowed to be aliased with input variables unless
otherwise noted.

Matrices are indexed from zero: an $m \times n$ matrix
has rows of index $0,1,\ldots,m-1$ and columns of
index $0,1,\ldots,n-1$. One or both of $m$ and $n$ may be zero.

Elements of a matrix can be read or written using the \code{fmpz_mat_entry}
macro, which returns a reference to the entry at a given row and column index.
This reference can be passed as an input or output \code{fmpz_t} variable to
any function in the \code{fmpz} module for direct manipulation.

\section{Simple example}
The following example creates the $2 \times 2$ matrix $A$ with
value $2i+j$ at row~$i$ and column~$j$, computes $B = A^2$,
and prints both matrices.

\begin{lstlisting}[language=c]
#include "fmpz.h"
#include "fmpz_mat.h"
...
long i, j;
fmpz_mat_t A;
fmpz_mat_t B;
fmpz_mat_init(A, 2, 2);
fmpz_mat_init(B, 2, 2);
for (i = 0; i < 2; i++)
    for (j = 0; j < 2; j++)
        fmpz_set_ui(fmpz_mat_entry(A, i, j), 2*i+j);
fmpz_mat_mul(B, A, A);
flint_printf("A = \n");
fmpz_mat_print_pretty(A);
flint_printf("A^2 = \n");
fmpz_mat_print_pretty(B);
fmpz_mat_clear(A);
fmpz_mat_clear(B);
\end{lstlisting}

The output is:
\begin{lstlisting}
A =
[[0 1]
[2 3]]
A^2 =
[[2 3]
[6 11]]
\end{lstlisting}


\input{input/fmpz_mat.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Integer polynomials                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{fmpz\_poly: Polynomials over arbitrary precision integers}
\epigraph{Polynomials over $\Z$}{}

\section{Introduction}

The \code{fmpz_poly_t} data type represents elements of $\Z[x]$. The
\code{fmpz_poly} module provides routines for memory management, basic
arithmetic, and conversions from or to other types.

Each coefficient of an \code{fmpz_poly_t} is an integer of the FLINT
\code{fmpz_t} type.  There are two advantages of this model.  Firstly,
the \code{fmpz_t} type is memory managed, so the user can manipulate
individual coefficients of a polynomial without having to deal with
tedious memory management.  Secondly, a coefficient of an
\code{fmpz_poly_t} can be changed without changing the size of any
of the other coefficients.

Unless otherwise specified, all functions in this section permit aliasing
between their input arguments and between their input and output arguments.

\section{Simple example}

The following example computes the square of the polynomial $5x^3 - 1$.
\begin{lstlisting}[language=c]
#include "fmpz_poly.h"
...
fmpz_poly_t x, y;
fmpz_poly_init(x);
fmpz_poly_init(y);
fmpz_poly_set_coeff_ui(x, 3, 5);
fmpz_poly_set_coeff_si(x, 0, -1);
fmpz_poly_mul(y, x, x);
fmpz_poly_print(x); flint_printf("\n");
fmpz_poly_print(y); flint_printf("\n");
fmpz_poly_clear(x);
fmpz_poly_clear(y);
\end{lstlisting}

The output is:
\begin{lstlisting}
4  -1 0 0 5
7  1 0 0 -10 0 0 25
\end{lstlisting}

\section{Definition of the fmpz\_poly\_t type}

The \code{fmpz_poly_t} type is a typedef for an array of length~1 of
\code{fmpz_poly_struct}'s.  This permits passing parameters of type
\code{fmpz_poly_t} by reference in a manner similar to the way GMP integers
of type \code{mpz_t} can be passed by reference.

In reality one never deals directly with the \code{struct} and simply deals
with objects of type \code{fmpz_poly_t}.  For simplicity we will think of an
\code{fmpz_poly_t} as a \code{struct}, though in practice to access fields
of this \code{struct}, one needs to dereference first, e.g.\ to access the
\code{length} field of an \code{fmpz_poly_t} called \code{poly1} one writes
\code{poly1->length}.

An \code{fmpz_poly_t} is said to be \emph{normalised} if either
\code{length} is zero, or if the leading coefficient of the polynomial is
non-zero.  All \code{fmpz_poly} functions expect their inputs to be
normalised, and unless otherwise specified they produce output that is
normalised.

It is recommended that users do not access the fields of an
\code{fmpz_poly_t} or its coefficient data directly, but make use of the
functions designed for this purpose, detailed below.

Functions in \code{fmpz_poly} do all the memory management for the user.
One does not need to specify the maximum length or number of limbs per
coefficient in advance before using a polynomial object.  FLINT reallocates
space automatically as the computation proceeds, if more space is required.
Each coefficient is also managed separately, being resized as needed,
independently of the other coefficients.

We now describe the functions available in \code{fmpz_poly}.

\input{input/fmpz_poly.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Integer polynomial factorisation                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{fmpz\_poly\_factor: Polynomial factorisation over $\Z$}
\epigraph{Factorisation of polynomials over $\Z$}{}

\input{input/fmpz_poly_factor.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Multivariate integer polynomials
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{fmpz\_mpoly: Multivariate polynomials over arbitrary precision integers}
\epigraph{Multivariate polynomials over $\Z$}{}

\input{input/fmpz_mpoly.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Rational numbers                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{fmpq: Arbitrary precision rationals}
\epigraph{Arbitrary-precision rational numbers}{}

\section{Introduction}

The \code{fmpq_t} data type represents rational numbers
as fractions of multiprecision integers.

An \code{fmpq_t} is an array of length 1 of type \code{fmpq},
with \code{fmpq} being implemented as a pair of \code{fmpz}'s
representing numerator and denominator.

This format is designed to allow rational numbers with small
numerators or denominators to be stored and manipulated
efficiently. When components no longer fit in single
machine words, the cost of \code{fmpq_t} arithmetic
is roughly the same as that of \code{mpq_t} arithmetic,
plus a small amount of overhead.

A fraction is said to be in canonical form if the numerator
and denominator have no common factor and the denominator is
positive. Except where otherwise noted, all functions in the
\code{fmpq} module assume that
inputs are in canonical form, and produce outputs in canonical form.
The user can manipulate the numerator and denominator of an
\code{fmpq_t} as arbitrary integers, but then becomes
responsible for canonicalising the number (for example by calling
\code{fmpq_canonicalise}) before passing it to any library function.

For most operations, both a function operating
on \code{fmpq_t}'s and an underscore version operating
on \code{fmpz_t} components are provided. The underscore
functions may perform less error checking,
and may impose limitations on aliasing between the
input and output variables, but
generally assume that the components are in
canonical form just like the non-underscore functions.

\input{input/fmpq.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Rational matrices                                                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{fmpq\_mat: Matrices over the rationals}
\epigraph{Matrices over $\Q$}{}

\section{Introduction}

The \code{fmpq_mat_t} data type represents matrices over $\Q$.

A rational matrix is stored as an array of \code{fmpq} elements in order
to allow convenient and efficient manipulation of individual entries.
In general, \code{fmpq_mat} functions assume that input entries are
in canonical form, and produce output with entries in canonical form.

Since rational arithmetic is expensive, computations are typically performed
by clearing denominators, performing the heavy work over the integers,
and converting the final result back to a rational matrix. The
\code{fmpq_mat} functions take care of such conversions transparently.
For users who need fine-grained control, various
functions for conversion between rational and integer matrices are provided.

\input{input/fmpq_mat.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Rational polynomials                                                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{fmpq\_poly: Polynomials over the rationals}
\epigraph{Polynomials over $\Q$}{}

\section{Introduction}

The \code{fmpq_poly_t} data type represents elements of $\Q[x]$. The
\code{fmpq_poly} module provides routines for memory management, basic
arithmetic, and conversions from or to other types.

A rational polynomial is stored as the quotient of an integer polynomial
and an integer denominator.  To be more precise, the coefficient vector
of the numerator can be accessed with the function \code{fmpq_poly_numref()}
and the denominator with \code{fmpq_poly_denref()}.  Although one can
construct use cases in which a representation as a list of rational
coefficients would be beneficial, the choice made here is typically
more efficient.

We can obtain a unique representation based on this choice by enforcing,
for non-zero polynomials, that the numerator and denominator are coprime
and that the denominator is positive.  The unique representation of the
zero polynomial is chosen as $0/1$.

Similar to the situation in the \code{fmpz_poly_t} case, an
\code{fmpq_poly_t} object also has a \code{length} parameter, which
denotes the length of the vector of coefficients of the numerator.
We say a polynomial is \emph{normalised} either if this length is zero
or if the leading coefficient is non-zero.

We say a polynomial is in \emph{canonical} form if it is given in the
unique representation discussed above and normalised.

The functions provided in this module roughly fall into two categories:

On the one hand, there are functions mainly provided for the user, whose
names do not begin with an underscore.  These typically operate on
polynomials of type \code{fmpq_poly_t} in canonical form and, unless
specified otherwise, permit aliasing between their input arguments and
between their output arguments.

On the other hand, there are versions of these functions whose names are
prefixed with a single underscore.  These typically operate on polynomials
given in the form of a triple of object of types \code{fmpz *},
\code{fmpz_t}, and \code{slong}, containing the numerator, denominator and
length, respectively.  In general, these functions expect their input to
be normalised, i.e.\ they do not allow zero padding, and to be in lowest
terms, and they do not allow their input and output arguments to be aliased.

\input{input/fmpq_poly.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Rational functions                                                           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{fmpz\_poly\_q: Rational functions}
\epigraph{Rational functions over $\Q$}{}

\section{Introduction}

The module \code{fmpz_poly_q} provides functions for performing
arithmetic on rational functions in $\mathbf{Q}(t)$, represented as
quotients of integer polynomials of type \code{fmpz_poly_t}.  These
functions start with the prefix \code{fmpz_poly_q_}.

Rational functions are stored in objects of type \code{fmpz_poly_q_t},
which is an array of \code{fmpz_poly_q_struct}'s of length one.  This
permits passing parameters of type \code{fmpz_poly_q_t} by reference.

The representation of a rational function as the quotient of two integer
polynomials can be made canonical by demanding the numerator and
denominator to be coprime (as integer polynomials) and the denominator to
have positive leading coefficient.  As the only special case, we represent
the zero function as $0/1$.  All arithmetic functions assume that the
operands are in this canonical form, and canonicalize their result.  If the
numerator or denominator is modified individually, for example using the
macros \code{fmpz_poly_q_numref()} and \code{fmpz_poly_q_denref()},
it is the user's responsibility to canonicalise the rational function
using the function \code{fmpz_poly_q_canonicalise()} if necessary.

All methods support aliasing of their inputs and outputs \emph{unless}
explicitly stated otherwise, subject to the following caveat.  If
different rational functions (as objects in memory, not necessarily in the
mathematical sense) share some of the underlying integer polynomial
objects, the behaviour is undefined.

The basic arithmetic operations, addition, subtraction and multiplication,
are all implemented using adapted versions of Henrici's algorithms,
see~\citep{Hen1956}.  Differentiation is implemented in a way slightly
improving on the algorithm described in~\citep{Hor1972}.

\section{Simple example}


The following example computes the product of two rational functions and
prints the result:
\begin{lstlisting}[language=c]
#include "fmpz_poly_q.h"
...
char *str, *strf, *strg;
fmpz_poly_q_t f, g;
fmpz_poly_q_init(f);
fmpz_poly_q_init(g);
fmpz_poly_q_set_str(f, "2  1 3/1  2");
fmpz_poly_q_set_str(g, "1  3/2  2 7");
strf = fmpz_poly_q_get_str_pretty(f, "t");
strg = fmpz_poly_q_get_str_pretty(g, "t");
fmpz_poly_q_mul(f, f, g);
str  = fmpz_poly_q_get_str_pretty(f, "t");
flint_printf("%s * %s = %s\n", strf, strg, str);
free(str);
free(strf);
free(strg);
fmpz_poly_q_clear(f);
fmpz_poly_q_clear(g);
\end{lstlisting}

The output is:
\begin{lstlisting}[language=c]
(3*t+1)/2 * 3/(7*t+2) = (9*t+3)/(14*t+4)
\end{lstlisting}

\input{input/fmpz_poly_q.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Multivariate integer polynomials
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{fmpq\_mpoly: Multivariate polynomials over the rationals}
\epigraph{Multivariate polynomials over $\Q$}{}

\input{input/fmpq_mpoly.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Matrices over integer polynomials                                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{fmpz\_poly\_mat: Polynomial matrices over $\Z$}
\epigraph{Matrices over $\mathbf{Z}[x]$}{}

The \code{fmpz_poly_mat_t} data type represents matrices whose
entries are integer polynomials.

The \code{fmpz_poly_mat_t} type is defined as an array of
\code{fmpz_poly_mat_struct}'s of length one.
This  permits passing parameters of type \code{fmpz_poly_mat_t}
by reference.

An integer polynomial matrix internally consists of a single array
of \code{fmpz_poly_struct}'s, representing a dense matrix in
row-major order. This array is only directly indexed
during memory allocation and deallocation. A separate array
holds pointers to the start of each row, and is used for all
indexing. This allows the rows of a matrix to be permuted
quickly by swapping pointers.

Matrices having zero rows or columns are allowed.

The shape of a matrix is fixed upon initialisation.
The user is assumed to provide input and output variables
whose dimensions are compatible with the given operation.

\section{Simple example}

The following example constructs the matrix
$\begin{pmatrix} 2x+1 & x \\ 1-x & -1 \end{pmatrix}$ and computes
its determinant.

\begin{lstlisting}[language=c]
#include "fmpz_poly.h"
#include "fmpz_poly_mat.h"
...
fmpz_poly_mat_t A;
fmpz_poly_t P;

fmpz_poly_mat_init(A, 2, 2);
fmpz_poly_init(P);

fmpz_poly_set_str(fmpz_poly_mat_entry(A, 0, 0), "2  1 2");
fmpz_poly_set_str(fmpz_poly_mat_entry(A, 0, 1), "2  0 1");
fmpz_poly_set_str(fmpz_poly_mat_entry(A, 1, 0), "2  1 -1");
fmpz_poly_set_str(fmpz_poly_mat_entry(A, 1, 1), "1  -1");

fmpz_poly_mat_det(P, A);
fmpz_poly_print_pretty(P, "x");

fmpz_poly_clear(P);
fmpz_poly_mat_clear(A);
\end{lstlisting}

The output is:
\begin{lstlisting}[language=c]
x^2-3*x-1
\end{lstlisting}

\input{input/fmpz_poly_mat.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Vectors over Z / nZ for word-sized moduli                                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{nmod\_vec: Vectors over $\Z/n\Z$ (small $n$)}
\epigraph{Vectors over $\Z / n \Z$ for word-sized moduli}{}

\input{input/nmod_vec.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Polynomials over Z / nZ for word-sized moduli                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{nmod\_poly: Polynomials over $\Z/n\Z$ (small $n$)}
\epigraph{Polynomials over $\Z / n \Z$ for word-sized moduli}{}

\section{Introduction}

The \code{nmod_poly_t} data type represents elements of $\Z/n\Z[x]$ for
a fixed modulus $n$. The \code{nmod_poly} module provides routines for
memory management, basic arithmetic and some higher level functions
such as GCD, etc.

Each coefficient of an \code{nmod_poly_t} is of type \code{mp_limb_t}
and represents an integer reduced modulo the fixed modulus $n$.

Unless otherwise specified, all functions in this section permit aliasing
between their input arguments and between their input and output arguments.

\section{Simple example}

The following example computes the square of the polynomial $5x^3 + 6$
in $\Z/7\Z[x]$.
\begin{lstlisting}[language=c]
#include "nmod_poly.h"
...
nmod_poly_t x, y;
nmod_poly_init(x, 7);
nmod_poly_init(y, 7);
nmod_poly_set_coeff_ui(x, 3, 5);
nmod_poly_set_coeff_ui(x, 0, 6);
nmod_poly_mul(y, x, x);
nmod_poly_print(x); flint_printf("\n");
nmod_poly_print(y); flint_printf("\n");
nmod_poly_clear(x);
nmod_poly_clear(y);
\end{lstlisting}

The output is:
\begin{lstlisting}
4 7  6 0 0 5
7 7  1 0 0 4 0 0 4
\end{lstlisting}

\section{Definition of the nmod\_poly\_t type}

The \code{nmod_poly_t} type is a typedef for an array of length~1 of
\code{nmod_poly_struct}'s.  This permits passing parameters of type
\code{nmod_poly_t} by reference.

In reality one never deals directly with the \code{struct} and simply deals
with objects of type \code{nmod_poly_t}.  For simplicity we will think of an
\code{nmod_poly_t} as a \code{struct}, though in practice to access fields
of this \code{struct}, one needs to dereference first, e.g.\ to access the
\code{length} field of an \code{nmod_poly_t} called \code{poly1} one writes
\code{poly1->length}.

An \code{nmod_poly_t} is said to be \emph{normalised} if either
\code{length} is zero, or if the leading coefficient of the polynomial is
non-zero.  All \code{nmod_poly} functions expect their inputs to be
normalised and for all coefficients to be reduced modulo $n$, and unless
otherwise specified they produce output that is normalised with
coefficients reduced modulo $n$.

It is recommended that users do not access the fields of an
\code{nmod_poly_t} or its coefficient data directly, but make use of the
functions designed for this purpose, detailed below.

Functions in \code{nmod_poly} do all the memory management for the user.
One does not need to specify the maximum length in advance before using a
polynomial object.  FLINT reallocates space automatically as the computation
proceeds, if more space is required.

We now describe the functions available in \code{nmod_poly}.

\input{input/nmod_poly.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Factorisation of polynomials over Z / nZ for word-sized moduli               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{nmod\_poly\_factor: Polynomial factorisation over $\Z/n\Z$ (small $n$)}
\epigraph{Factorisation of polynomials over $\Z / n \Z$ for word-sized moduli}{}

The \code{nmod_poly_factor} module is included automatically with
\code{nmod_poly.h}. One should not try to include \code{nmod_poly_factor.h}
directly.

\input{input/nmod_poly_factor.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Matrices over Z / nZ for word-sized moduli                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{nmod\_mat: Matrices over $\Z/n\Z$ (small $n$)}
\epigraph{Matrices over $\Z / n \Z$ for word-sized moduli}{}

\section{Introduction}

An \code{nmod_mat_t} represents a matrix of integers modulo $n$, for any
non-zero modulus $n$ that fits in a single limb,
up to $2^{32}-1$ or $2^{64}-1$.

The \code{nmod_mat_t} type is defined as an array of
\code{nmod_mat_struct}'s of length one.
This  permits passing parameters of type \code{nmod_mat_t}
by reference.

An \code{nmod_mat_t} internally consists of a single array of
\code{mp_limb_t}'s, representing a dense matrix in row-major order.
This array is only directly indexed during memory allocation and
deallocation. A separate array holds pointers to the start of each
row, and is used for all indexing. This allows the rows of a matrix
to be permuted quickly by swapping pointers.

Matrices having zero rows or columns are allowed.

The shape of a matrix is fixed upon initialisation.
The user is assumed to provide input and output variables
whose dimensions are compatible with the given operation.

It is assumed that all matrices passed to a function have the same modulus.
The modulus is assumed to be a prime number in functions that
perform some kind of division, solving, or Gaussian elimination
(including computation of rank and determinant),
but can be composite in functions that only perform basic manipulation
and ring operations (e.g. transpose and matrix multiplication).

The user can manipulate matrix entries directly, but must
assume responsibility for normalising all values to the range $[0, n)$.

\input{input/nmod_mat.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Matrices over integer polynomials mod n                                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{nmod\_poly\_mat: Polynomial matrices over $\Z/n\Z$ (small $n$)}
\epigraph{Matrices over $\Z / n \Z[x]$ for word-sized moduli}{}

The \code{nmod_poly_mat_t} data type represents matrices whose
entries are polynomials having coefficients in $\Z / n \Z$.
We generally assume that $n$ is a prime number.

The \code{nmod_poly_mat_t} type is defined as an array of
\code{nmod_poly_mat_struct}'s of length one.
This permits passing parameters of type \code{nmod_poly_mat_t}
by reference.

A matrix internally consists of a single array
of \code{nmod_poly_struct}'s, representing a dense matrix in
row-major order. This array is only directly indexed
during memory allocation and deallocation. A separate array
holds pointers to the start of each row, and is used for all
indexing. This allows the rows of a matrix to be permuted
quickly by swapping pointers.

Matrices having zero rows or columns are allowed.

The shape of a matrix is fixed upon initialisation.
The user is assumed to provide input and output variables
whose dimensions are compatible with the given operation.

\input{input/nmod_poly_mat.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Polynomials over Z/nZ for general moduli                                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{fmpz\_mod\_poly: Polynomials over $\Z/n\Z$}
\epigraph{Polynomials over $\Z / n \Z$ for general moduli}{}

\section{Introduction}

The \code{fmpz_mod_poly_t} data type represents elements of $\Z/n\Z[x]$ for
a fixed modulus $n$. The \code{fmpz_mod_poly} module provides routines for
memory management, basic arithmetic and some higher level functions
such as GCD, etc.

Each coefficient of an \code{fmpz_mod_poly_t} is of type \code{fmpz}
and represents an integer reduced modulo the fixed modulus $n$ in the
range $[0,n)$.

Unless otherwise specified, all functions in this section permit aliasing
between their input arguments and between their input and output arguments.

\section{Simple example}

The following example computes the square of the polynomial $5x^3 + 6$
in $\Z/7\Z[x]$.
\begin{lstlisting}[language=c]
#include "fmpz_mod_poly.h"
...
fmpz_t n;
fmpz_mod_poly_t x, y;

fmpz_init_set_ui(n, 7);
fmpz_mod_poly_init(x, n);
fmpz_mod_poly_init(y, n);
fmpz_mod_poly_set_coeff_ui(x, 3, 5);
fmpz_mod_poly_set_coeff_ui(x, 0, 6);
fmpz_mod_poly_sqr(y, x);
fmpz_mod_poly_print(x); flint_printf("\n");
fmpz_mod_poly_print(y); flint_printf("\n");
fmpz_mod_poly_clear(x);
fmpz_mod_poly_clear(y);
fmpz_clear(n);
\end{lstlisting}

The output is:
\begin{lstlisting}
4 7  6 0 0 5
7 7  1 0 0 4 0 0 4
\end{lstlisting}

\section{Definition of the fmpz\_mod\_poly\_t type}

The \code{fmpz_mod_poly_t} type is a typedef for an array of length~1 of\\
\code{fmpz_mod_poly_struct}'s.  This permits passing parameters of type
\code{fmpz_mod_poly_t} by reference.

In reality one never deals directly with the \code{struct} and simply deals
with objects of type \code{fmpz_mod_poly_t}.  For simplicity we will think of an
\code{fmpz_mod_poly_t} as a \code{struct}, though in practice to access fields
of this \code{struct}, one needs to dereference first, e.g.\ to access the
\code{length} field of an \code{fmpz_mod_poly_t} called \code{poly1} one writes
\code{poly1->length}.

An \code{fmpz_mod_poly_t} is said to be \emph{normalised} if either
\code{length} is zero, or if the leading coefficient of the polynomial is
non-zero.  All \code{fmpz_mod_poly} functions expect their inputs to be
normalised and all coefficients to be reduced modulo~$n$, and unless
otherwise specified they produce output that is normalised with coefficients
reduced modulo~$n$.

It is recommended that users do not access the fields of an
\code{fmpz_mod_poly_t} or its coefficient data directly, but make use of the
functions designed for this purpose, detailed below.

Functions in \code{fmpz_mod_poly} do all the memory management for the user.
One does not need to specify the maximum length in advance before using a
polynomial object.  FLINT reallocates space automatically as the computation
proceeds, if more space is required.

We now describe the functions available in \code{fmpz_mod_poly}.

\input{input/fmpz_mod_poly.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Polynomial factorisation over Z/nZ                                           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{fmpz\_mod\_poly\_factor: Polynomial factorisation over $\Z/n\Z$}
\epigraph{Factorisation of polynomials over $\Z/n\Z$ for general moduli}{}

The \code{fmpz_mod_poly_factor} module is included automatically when one
includes \code{fmpz_mod_poly.h}. One should not try to include
\code{fmpz_mod_poly_factor.h} directly.

\input{input/fmpz_mod_poly_factor.tex}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Finite Fields (fq)                                                           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{fq: Finite fields}
\epigraph{Finite fields of arbitrary characteristic}

We represent an element of the finite field $\mathbf{F}_{p^n} \cong
\mathbf{F}_p[X]/(f(X))$, where $f(X) \in \mathbf{F}_p[X]$ is a monic,
irreducible polynomial of degree~$n$, as a polynomial in
$\mathbf{F}_p[X]$ of degree less than $n$. The underlying data
structure is an \code{fmpz_poly_t}.

The default choice for $f(X)$ is the Conway polynomial for the pair
$(p,n)$.  Frank Luebeck's data base of Conway polynomials is made
available in the file \code{qadic/CPimport.txt}.  If a Conway
polynomial is not available, then a random irreducible polynomial will
be chosen for $f(X)$.  Additionally, the user is able to supply their
own $f(X)$.

\input{input/fq.tex}
\input{input/fq_embed.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% fq_vec                                                                       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{fq\_vec: Vectors over finite fields}
\epigraph{Vectors over finite fields of arbitrary characteristic}

\input{input/fq_vec.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% fq_mat                                                                       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{fq\_mat: Matrices over finite fields}
\epigraph{Matrices over finite fields of arbitrary characteristic}

\input{input/fq_mat.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% fq_poly                                                                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{fq\_poly: Polynomials over finite fields}
\epigraph{polynomials over finite fields of arbitrary characteristic}

We represent a polynomial in $\mathbf{F}_q[X]$ as a \code{struct}
which includes an array \code{coeffs} with the coefficients, as well
as the length \code{length} and the number \code{alloc} of
coefficients for which memory has been allocated.

As a data structure, we call this polynomial \emph{normalised}
if the top coefficient is non-zero.

Unless otherwise stated here, all functions that deal with polynomials
assume that the $\mathbf{F}_q$ context of said polynomials are compatible,
i.e., it assumes that the fields are generated by the same polynomial.

\input{input/fq_poly.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% fq_poly_factor                                                               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{fq\_poly\_factor: Polynomial factorisation over finite fields}
\epigraph{Factorisation of polynomials over finite fields of arbitrary
  characteristic}

The \code{fq_poly_factor} module is included automatically when one
includes \code{fq_poly.h}. One should not try to include
\code{fq_poly_factor.h} directly.

\input{input/fq_poly_factor.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% fq_nmod                                                                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{fq\_nmod: Finite fields (small representation)}
\epigraph{Finite fields of word-sized characteristic}


We represent an element of the finite field $\mathbf{F}_{p^n} \cong
\mathbf{F}_p[X]/(f(X))$, where $f(X) \in \mathbf{F}_p[X]$ is a monic,
irreducible polynomial of degree~$n$, as a polynomial in
$\mathbf{F}_p[X]$ of degree less than $n$.  The underlying data
structure is an \code{nmod_poly_t}.

The default choice for $f(X)$ is the Conway polynomial for the pair
$(p,n)$.  Frank Luebeck's data base of Conway polynomials is made
available in the file \code{qadic/CPimport.txt}.  If a Conway
polynomial is not available, then a random irreducible polynomial will
be chosen for $f(X)$.  Additionally, the user is able to supply their
own $f(X)$.

\input{input/fq_nmod.tex}
\input{input/fq_nmod_embed.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% fq_nmod_vec                                                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{fq\_nmod\_vec: Vectors over finite fields (small representation)}
\epigraph{Vectors over finite fields of word-sized characteristic}

\input{input/fq_nmod_vec.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% fq_nmod_mat                                                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{fq\_nmod\_mat: Matrices over finite fields (small representation)}
\epigraph{Matrices over finite fields of word-sized characteristic}

\input{input/fq_nmod_mat.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% fq_nmod_poly                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{fq\_nmod\_poly: Polynomials over finite fields (small representation)}
\epigraph{polynomials over finite fields of word-sized characteristic}

We represent a polynomial in $\mathbf{F}_q[X]$ as a \code{struct}
which includes an array \code{coeffs} with the coefficients, as well
as the length \code{length} and the number \code{alloc} of
coefficients for which memory has been allocated.

As a data structure, we call this polynomial \emph{normalised} if the
top coefficient is non-zero.

Unless otherwise stated here, all functions that deal with polynomials
assume that the $\mathbf{F}_q$ context of said polynomials are
compatible, i.e., it assumes that the fields are generated by the same
polynomial.


\input{input/fq_nmod_poly.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% fq_nmod_poly_factor                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{fq\_nmod\_poly\_factor: Polynomial factorisation over finite fields
          (small representation)}
\epigraph{Factorisation of polynomials over finite fields of
  word-sized characteristic}

The \code{fq_nmod_poly_factor} module is included automatically when
one includes \code{fq_nmod_poly.h}. One should not try to include
\code{fq_nmod_poly_factor.h} directly.

\input{input/fq_nmod_poly_factor.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% fq_zech                                                                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{fq\_zech: Finite fields (Zech representation)}
\epigraph{Finite fields in Zech logarithm representation}

We represent an element of the finite field as a power of a generator
for the multiplicative group of the finite field.  In particular, we
use a root of $f(x)$, where $f(X) \in \mathbf{F}_p[X]$ is a monic,
irreducible polynomial of degree~$n$, as a polynomial in
$\mathbf{F}_p[X]$ of degree less than $n$.  The underlying data
structure is just an \code{mp_limb_t}.

The default choice for $f(X)$ is the Conway polynomial for the pair
$(p,n)$.  Frank Luebeck's data base of Conway polynomials is made
available in the file \code{qadic/CPimport.txt}.  If a Conway
polynomial is not available, then a random irreducible polynomial will
be chosen for $f(X)$.  Additionally, the user is able to supply their
own $f(X)$.

We required that the order of the field fits inside of an
\code{mp_limb_t}; however, it is recommended that $p^n < 2^{20}$ due
to the time and memory needed to compute the Zech logarithm table.

\input{input/fq_zech.tex}
\input{input/fq_zech_embed.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% fq_zech_vec                                                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{fq\_zech\_vec: Vectors over finite fields (Zech representation)}
\epigraph{Vectors over finite fields in Zech logarithm representation}

\input{input/fq_zech_vec.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% fq_zech_mat                                                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{fq\_zech\_mat: Matrices over finite fields (Zech representation)}
\epigraph{Matrices over finite fields in Zech logarithm representation}

\input{input/fq_zech_mat.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% fq_zech_poly                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{fq\_zech\_poly: Polynomials over finite fields (Zech representation)}
\epigraph{Polynomials over finite fields in Zech logarithm representation}

We represent a polynomial in $\mathbf{F}_q[X]$ as a \code{struct}
which includes an array \code{coeffs} with the coefficients, as well
as the length \code{length} and the number \code{alloc} of
coefficients for which memory has been allocated.

As a data structure, we call this polynomial \emph{normalised} if the
top coefficient is non-zero.

Unless otherwise stated here, all functions that deal with polynomials
assume that the $\mathbf{F}_q$ context of said polynomials are
compatible, i.e., it assumes that the fields are generated by the same
polynomial.

\input{input/fq_zech_poly.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% fq_zech_poly_factor                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{fq\_zech\_poly\_factor: Polynomial factorisation over finite fields
         (Zech representation)}
\epigraph{Factorisation of polynomials over finite fields in Zech
  logarithm representation}

The \code{fq_zech_poly_factor} module is included automatically when
one includes \code{fq_zech_poly.h}. One should not try to include
\code{fq_zech_poly_factor.h} directly.

\input{input/fq_zech_poly_factor.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Padic numbers                                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{padic: $p$-adic numbers ($\Q_p$)}
\epigraph{$p$-Adic numbers in $\mathbf{Q}_p$}{}

\section{Introduction}

The \code{padic_t} data type represents elements of $\mathbf{Q}_p$ to
precision~$N$, stored in the form $x = p^v u$ with $u, v \in \mathbf{Z}$.
Arithmetic operations can be carried out with respect to a context
containing the prime number $p$ and various pieces of pre-computed data.

Independent of the context, we consider a $p$-adic number
$x = u p^v$ to be in \emph{canonical form} whenever either
$p \nmid u$ or $u = v = 0$, and we say it is \emph{reduced}
if, in addition, for non-zero~$u$, $u \in (0, p^{N-v})$.

We briefly describe the interface:

The functions in this module expect arguments of type \code{padic_t},
and each variable carries its own precision.  The functions have an
interface that is similar to the MPFR functions.  In particular, they
have the same semantics, specified as follows:  Compute the requested
operation exactly and then reduce the result to the precision of the
output variable.

\input{input/padic.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Matrices of padic numbers                                                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{padic\_mat: Matrices over $\Q_p$}
\input{input/padic_mat.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Polynomials of padic numbers                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{padic\_poly: Polynomials over $\Q_p$}
\input{input/padic_poly.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Finite unramified extensions of the padic numbers                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{qadic: Unramified extensions of $\Q_p$}
\input{input/qadic.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APRCL primality test                                                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{aprcl: Primality test for \texttt{fmpz}}
\epigraph{APR-CL primality test}{}

\section{Introduction}

This module provides the APR-CL primality test implementation for \code{fmpz_t}
numbers.

The APR-CL test uses the Jacobi sums that belong $\mathbb{Z}[\zeta]/(n)$, 
so we have \code{unity_zp} struct and some useful operations. \code{unity_zp} 
is just a wrapper over \code{fmpz_mod_poly} with additional fields.

Also provides Gauss sum test, which is not very useful in practice, but can be
useful for people who want to see an implementation of these. Gauss sums 
belong $\mathbb{Z}[\zeta_q, \zeta_p]/(n)$ and implemented in \code{unity_zpq} 
struct.

We now describe the functions available in the \code{aprcl} module.

\input{input/aprcl.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arithmetic functions                                                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{arith: Arithmetic functions}
\epigraph{Arithmetic functions}{}

\section{Introduction}

This module implements arithmetic functions, number-theoretic and
combinatorial special number sequences and polynomials.

\input{input/arith.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Unsigned single limb arithmetic                                              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{ulong\_extras: Arithmetic for single word unsigned integers}
\epigraph{Unsigned single limb arithmetic}{}

\section{Introduction}

This module implements functions for single limb unsigned integers,
including arithmetic with a precomputed inverse and modular arithmetic.

The module includes functions for square roots, factorisation and
primality testing. Almost all the functions in this module are highly
developed and extremely well optimised.

The basic type is the \code{mp_limb_t} as defined by MPIR. Functions
which take a precomputed inverse either have the suffix \code{preinv}
and take an \code{mp_limb_t} precomputed inverse as computed by
\code{n_preinvert_limb} or have the suffix \code{_precomp} and accept
a \code{double} precomputed inverse as computed by
\code{n_precompute_inverse}.

Sometimes three functions with similar names are provided for the
same task, e.g. \code{n_mod_precomp}, \code{n_mod2_precomp} and
\code{n_mod2_preinv}. If the part of the name that designates the
functionality ends in 2 then the function has few if any limitations
on its inputs. Otherwise the function may have limitations such as
being limited to 52 or 53 bits. In practice we found that the
preinv functions are generally faster anyway, so most times it pays
to just use the \code{n_blah2_preinv} variants.

Some functions with the \code{n_ll_} or \code{n_lll_} prefix accept
parameters of two or three limbs respectively.

\section{Simple example}

The following example computes $ab \pmod{n}$ using a precomputed
inverse, where $a = 12345678, b = 87654321$ and $n = 111111111$.

\begin{lstlisting}[language=c]
#include <stdio.h>
#include "ulong_extras.h"
...
mp_limb_t r, a, b, n, ninv;

a = UWORD(12345678);
b = UWORD(87654321);
n = UWORD(111111111);
ninv = n_preinvert_limb(n);

r = n_mulmod2_preinv(a, b, n, ninv);

flint_printf("%wu*%wu mod %wu is %wu\n", a, b, n, r);
\end{lstlisting}

The output is:
\begin{lstlisting}[language=c]
12345678*87654321 mod 111111111 is 23456790
\end{lstlisting}

\input{input/ulong_extras.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Signed single limb arithmetic                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{long\_extras: Arithmetic for single word signed integers}
\epigraph{Signed single limb arithmetic}{}

\input{input/long_extras.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Fast Fourier Transforms                                                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{fft: Fast Fourier Transform (integer and polynomial multiplication)}
\epigraph{Fast Fourier Transforms}{}

\input{input/fft.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Quadratic Sieve                                                              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{qsieve: Quadratic sieve for integer factorisation}
\epigraph{Quadratic sieve}{}

\input{input/qsieve.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Permutations                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{perm: Permutations}
\epigraph{Permutations}{}

\input{input/perm.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% longlong.h                                                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{longlong.h: Assembly macros for wide integer arithmetic}
\epigraph{$64$-bit arithmetic}

\input{input/longlong.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% mpn_extras                                                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{mpn\_extras: Extra function for the GMP mpn layer}

\input{input/mpn_extras.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% profiler                                                                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{profiler}

\input{input/profiler.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% interfaces                                                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{interfaces}
\epigraph{Interfaces to other packages}{}

\section{Introduction}

In this chapter we provide interfaces to various external packages.

\input{input/interfaces.tex}

\chapter{License}
\lstinputlisting[language={},breaklines=false,basicstyle=\scriptsize]{../../LICENSE}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BACKMATTER                                                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\backmatter

\phantomsection
\addcontentsline{toc}{chapter}{References}
\bibliographystyle{amsplain}
\bibliography{flint-manual}

\end{document}
